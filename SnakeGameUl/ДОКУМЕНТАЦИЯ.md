# Документация проекта SnakeGameUI

## Обзор архитектуры

Проект представляет собой консольную игру "Змейка" на C#, построенную по принципам объектно-ориентированного программирования. Основные компоненты взаимодействуют через четко определенные интерфейсы и обеспечивают модульность кода.

## Основные классы и их функции

### 1. Program.cs - Главный класс приложения

**Назначение**: Точка входа в приложение и управление основным игровым циклом.

#### Функция Main(string[] args)
**Что делает**: Управляет полным жизненным циклом игры от запуска до завершения.

**Сложные фрагменты кода**:

```csharp
while (true) // Основной цикл перезапуска игры
{
    // Инициализация звуковой системы
    string basePath = AppDomain.CurrentDomain.BaseDirectory;
    MusicManager.Initialize(basePath);
    
    // Создание игрока с системой жизней
    Player player = new Player(playerName, startPoint, Direction.RIGHT);
    player.Stats.LifeSystem = new LifeSystem(3);
    
    // Внутренний игровой цикл
    while (true)
    {
        // Проверка столкновений и система жизней
        if (walls.IsHit(player.Snake) || player.Snake.IsHitTail())
        {
            if (player.Stats.LifeSystem.LoseLife()) // Есть еще жизни
            {
                // Перезапуск с новой змейкой
                player.Stats.ResetAfterDeath();
                startPoint = new Point(4, 5 + gameOffsetY, '*');
                player.Snake = new Snake(startPoint, 4, Direction.RIGHT);
                continue; // Продолжаем игру
            }
            else
            {
                break; // Завершаем игру
            }
        }
    }
}
```

**Почему функции связаны**: 
- `MusicManager.Initialize()` подготавливает звуковую систему перед началом игры
- `Player` создается с привязкой к `LifeSystem` для управления жизнями
- `walls.IsHit()` и `player.Snake.IsHitTail()` проверяют условия потери жизни
- `player.Stats.LifeSystem.LoseLife()` определяет, продолжать игру или завершить

### 2. LifeSystem.cs - Система управления жизнями

**Назначение**: Управляет количеством жизней игрока и их отображением.

#### Функция LoseLife()
```csharp
public bool LoseLife()
{
    Lives--;
    return Lives > 0; // Возвращает true если игра продолжается
}
```
**Что делает**: Уменьшает количество жизней на 1 и возвращает информацию о том, может ли игра продолжаться.

#### Функция DisplayLives()
```csharp
public void DisplayLives()
{
    Console.SetCursorPosition(60, 1); // Позиция на экране
    Console.Write($"Elud: ");
    
    for (int i = 0; i < MaxLives; i++)
    {
        if (i < Lives)
            Console.Write("♥ "); // Заполненное сердце
        else
            Console.Write("♡ "); // Пустое сердце
    }
}
```
**Сложные фрагменты**:
- `Console.SetCursorPosition(60, 1)` - устанавливает курсор в правый верхний угол
- Цикл `for` отображает визуальное представление жизней через символы сердец
- `i < Lives` определяет, показывать заполненное или пустое сердце

#### Функция ShowLifeLostMessage()
```csharp
public void ShowLifeLostMessage()
{
    Console.SetCursorPosition(25, 12);
    Console.Write($"KAOTASID ELU! Jäänud elusid: {Lives}");
    System.Threading.Thread.Sleep(1500); // Пауза 1.5 секунды
    
    Console.SetCursorPosition(25, 12);
    Console.Write(new string(' ', 35)); // Очистка сообщения
}
```
**Что делает**: Показывает временное сообщение о потере жизни, затем очищает его.

**Связь с другими функциями**: Вызывается из `Program.Main()` при столкновении, работает совместно с `LoseLife()`.

### 3. Snake.cs - Класс змейки

**Назначение**: Основной игровой объект, управляет движением и логикой змейки.

#### Конструктор Snake(Point tail, int length, Direction _direction)
```csharp
public Snake(Point tail, int length, Direction _direction)
{
    direction = _direction;
    pList = new List<Point>(); // Список сегментов змейки
    for (int i = 0; i < length; i++)
    {
        Point p = new Point(tail);
        p.Move(i, direction); // Создание сегмента со смещением
        pList.Add(p);
    }
}
```
**Сложные фрагменты**:
- `pList` - список точек, представляющих сегменты змейки
- `p.Move(i, direction)` - каждый сегмент смещается на i позиций от хвоста
- Змейка создается "растянутой" в противоположном направлении движения

#### Функция Move()
```csharp
public void Move()
{
    Point tail = pList.First(); // Получаем хвост
    pList.Remove(tail); // Удаляем хвост из списка
    Point head = GetNextPoint(); // Вычисляем новую голову
    pList.Add(head); // Добавляем новую голову
    
    tail.Clear(); // Стираем хвост с экрана
    head.Draw(); // Рисуем новую голову
}
```
**Что делает**: Реализует движение змейки путем удаления хвоста и добавления новой головы.

**Связь функций**:
- `pList.First()` и `pList.Last()` работают с концами змейки
- `GetNextPoint()` вычисляет следующую позицию головы
- `tail.Clear()` и `head.Draw()` обновляют визуальное отображение

#### Функция Eat(Point food)
```csharp
public bool Eat(Point food)
{
    Point head = GetNextPoint(); // Следующая позиция головы
    if (head.IsHit(food)) // Проверка столкновения с едой
    {
        Point newHead = new Point(food.x, food.y, head.sym);
        pList.Add(newHead); // Добавляем голову БЕЗ удаления хвоста
        return true; // Еда съедена
    }
    else
        return false; // Еда не съедена
}
```
**Сложная логика**: При поедании еды хвост НЕ удаляется, что приводит к росту змейки на один сегмент.

#### Функция HandleKey(ConsoleKey key)
```csharp
public void HandleKey(ConsoleKey key)
{
    Direction newDirection = direction;
    
    if (key == ConsoleKey.LeftArrow && direction != Direction.RIGHT)
        newDirection = Direction.LEFT;
    // ... остальные направления
        
    direction = newDirection;
}
```
**Важная логика**: Проверка `direction != Direction.RIGHT` предотвращает движение змейки в противоположном направлении (самоубийство).

### 4. Stats.cs - Система статистики

**Назначение**: Управляет очками, статистикой игрока и интеграцией с системой жизней.

#### Функция UpdateScore(int points = 10)
```csharp
public void UpdateScore(int points = 10)
{
    int oldScore = Score;
    Score += points * ScoreMultiplier;
    Length++;
    
    // Проверка на получение дополнительной жизни
    if (oldScore / 100 < Score / 100 && LifeSystem != null)
    {
        LifeSystem.GainLife();
        LifeSystem.ShowLifeGainedMessage();
    }
}
```
**Сложная логика**:
- `oldScore / 100 < Score / 100` - проверяет, пересек ли счет границу в 100 очков
- Целочисленное деление используется для определения "сотен" очков
- При пересечении границы игрок получает дополнительную жизнь

**Связь с LifeSystem**: Функция напрямую взаимодействует с системой жизней, вызывая `GainLife()` и `ShowLifeGainedMessage()`.

#### Функция PrintStats()
```csharp
public void PrintStats()
{
    try
    {
        Console.SetCursorPosition(0, 0);
        string statsLine = $"Nimi: {Name,-15} Skoor: {Score,-6} Pikkus: {Length,-4} Rekord: {HighScore,-6} Tase: {Level}";
        Console.Write(statsLine.PadRight(Console.WindowWidth - 1));
        
        LifeSystem?.DisplayLives(); // Отображение жизней
    }
    catch (ArgumentOutOfRangeException) { }
}
```
**Сложные фрагменты**:
- `{Name,-15}` - форматирование с выравниванием по левому краю на 15 символов
- `PadRight(Console.WindowWidth - 1)` - заполнение строки до ширины консоли
- `LifeSystem?.DisplayLives()` - безопасный вызов с проверкой на null

### 5. Player.cs - Класс игрока

**Назначение**: Связующий класс между змейкой и статистикой.

```csharp
class Player
{
    public string Name { get; set; }
    public Stats Stats { get; set; }
    public Snake Snake { get; set; }
    
    public Player(string name, Point startPosition, Direction direction)
    {
        Name = name;
        Stats = new Stats { Name = name };
        Snake = new Snake(startPosition, 4, direction);
    }
}
```

**Связь компонентов**: Player объединяет Snake (игровую логику) и Stats (статистику), обеспечивая единую точку доступа к данным игрока.

## Взаимодействие между классами

### Цепочка обработки столкновения:
1. **Program.Main()** проверяет столкновение через `walls.IsHit()` и `snake.IsHitTail()`
2. При столкновении вызывается **LifeSystem.LoseLife()**
3. Если жизни остались, **LifeSystem.ShowLifeLostMessage()** показывает сообщение
4. **Stats.ResetAfterDeath()** сбрасывает длину змейки
5. Создается новый объект **Snake** с начальными параметрами
6. Игра продолжается с обновленным отображением

### Цепочка получения очков:
1. **Snake.Eat()** определяет поедание еды
2. **Stats.UpdateScore()** увеличивает счет
3. Внутри **UpdateScore()** проверяется условие для дополнительной жизни
4. При необходимости вызывается **LifeSystem.GainLife()**
5. **Stats.PrintStats()** обновляет отображение статистики
6. **LifeSystem.DisplayLives()** обновляет отображение жизней

### Система отображения:
- **Stats.PrintStats()** отвечает за верхнюю строку статистики
- **LifeSystem.DisplayLives()** отображает жизни в правой части экрана
- **Snake.Draw()** (наследуется от Figure) отображает змейку
- **Point.Draw()** отображает отдельные элементы (еда, сегменты змейки)

## Ключевые алгоритмы

### Алгоритм движения змейки:
1. Сохранить ссылку на хвост (`pList.First()`)
2. Удалить хвост из списка
3. Вычислить новую позицию головы
4. Добавить новую голову в список
5. Очистить старый хвост с экрана
6. Нарисовать новую голову

### Алгоритм роста при поедании:
1. Вычислить следующую позицию головы
2. Проверить столкновение с едой
3. Если столкновение есть - добавить новую голову БЕЗ удаления хвоста
4. Змейка автоматически становится длиннее на один сегмент

### Алгоритм системы жизней:
1. При столкновении уменьшить количество жизней
2. Если жизни > 0 - показать сообщение и перезапустить
3. Если жизни = 0 - завершить игру
4. При наборе каждых 100 очков - добавить жизнь (максимум 3)

Эта архитектура обеспечивает четкое разделение ответственности между классами и позволяет легко модифицировать отдельные компоненты без влияния на остальную систему.